\documentclass[a4paper,12pt]{article}

\usepackage{cmap}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}

\usepackage[russian, english]{babel}
%\usepackage{indentfirst}
\usepackage{titlesec}
\usepackage{amsthm}
\usepackage{lipsum}

\title{Общая надстрока наименьшей длины}
\author{Андрей Осипов}

\newtheorem{theorem}{Теорема}
\newtheorem{lemma}{Лемма}
\newtheorem{definition}{Определение}

\newcommand{\B}{\textbf}
\newcommand{\var}[1]{$\B{#1}$}

%%%%%%%%%% Document %%%%%%%%%%
\begin{document}
\Russian
\maketitle

\section{Постановка задачи}
Дан набор строк $S = \{s_1,\dots,s_n\}$ над конечным алфавитом. 
Требуется найти, строку $s$ минимальной длины, содержащую как подстроку каждую строку из данного набора.

Пусть язык $L$ это множество пар вида $(S, k)$ для которых верно, что такая строка $s$ существует, и имеет длину не больше $k$.
Тогда задача разрешения языка $L$ является NP-полной.
Доказательство этого факта будет приведено позже.
А пока, мы ослабим условие следующим образом: пускай теперь требуется найти такую строку $t$, 
что она так же как и $s$ содержит всякую строку из $S$ как подстроку, и при этом $|t| \leq 4*|s|$

\section{Алгоритм}
Алгоритм для решения этой задачи на первый взгляд может показаться крайне наивным.
Но в дальнейшем выяснится, что этого вполне достаточно для достижения даже такой близкой границы.
Более того, на практике полученный ответ разрастается не более чем вдвое.

Итак, без ограничения общности будем считать, что среди строк из $S$ нет таких двух $x$ и $y$, что $x$ подстрока $y$.
В противном случае от $x$ можно спокойно избавиться.

\begin{definition}
Пусть даны строки $x$ и $y$.
Представим их как $pr$+$ov$ и $ov$+$su$ соответственно, причем $|pr|>0$, $|su|>0$, $ov$ имеет максимальную возможную длину, а опетор (+) - это конкатенация строк.
Тогда определим $over(x, y) = ov$, $pref(x, y) = pr$ и $d(x, y) = |pr|$.
\end{definition}

\noindent Теперь запустим следующий алгоритм.
\begin{enumerate}
\item Если в множестве $S$ осталась ровно одна строка, то выведем её и прекратим работу алгоритма.
\item Иначе, переберём все упорядоченные пары различных строк $x$ и $y$ из $S$ и найдем среди них ту, у которой $|over(x, y)|$ максимален.
Если таких несколько можно выбрать любую. Например, лексикографически минимальную.
\item Найдя такую пару, выкинем из $S$ строки $x$ и $y$, а вместо них положим туда строку $pref(x, y)+y$. 
И перейдем к первому пункту алгоритма.
\end{enumerate}

\section{Доказательство}
Давайте посмотрим на то, что на самом деле происходит с исходными строками во время работы алгоритма.

\begin{lemma}

\end{lemma}

\section{NP-полнота}

\begin{theorem}
the1
\end{theorem}

\end{document}
