\documentclass[a4paper,10pt]{article}

\usepackage{cmap}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}

\usepackage[russian, english]{babel}
\usepackage{titlesec}
\usepackage{amsthm}
\usepackage{lipsum}

\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm,bindingoffset=0cm]{geometry}

\newcommand{\B}{\textbf}
\newcommand{\var}[1]{$\B{#1}$}

\title{\B{Общая надстрока наименьшей длины}}
\author{Андрей Осипов}

\newtheorem{theorem}{Теорема}
\newtheorem{lemma}{Лемма}
\newtheorem{definition}{Определение}
\newtheorem{note}{Замечание}

%%%%%%%%%% Document %%%%%%%%%%
\begin{document}
\Russian
\maketitle

\section{Постановка задачи}
Дан набор строк $S = \{s_1,\dots,s_n\}$ над конечным алфавитом. 
Требуется найти, строку $s$ минимальной длины, содержащую как подстроку каждую строку из данного набора.

Пусть язык $L$ это множество пар вида $(S, k)$ для которых верно, что такая строка $s$ существует, и имеет длину не больше $k$.
Тогда задача разрешения языка $L$ является NP-полной.
Доказательство этого факта будет приведено позже.
А пока, мы ослабим условие следующим образом: пускай теперь требуется найти такую строку $t$, 
что она так же как и $s$ содержит всякую строку из $S$ как подстроку, и при этом $|t| \leq 4*|s|$

\section{Алгоритм}
Алгоритм для решения этой задачи на первый взгляд может показаться крайне наивным.
Но в дальнейшем выяснится, что этого вполне достаточно для достижения даже такой близкой границы.
Более того, на практике полученный ответ разрастается не более чем вдвое.

Итак, без ограничения общности будем считать, что среди строк из $S$ нет таких двух $x$ и $y$, что $x$ подстрока $y$.
В противном случае от $x$ можно спокойно избавиться.

\begin{definition}
Пусть даны строки $x$ и $y$.
Представим их как $pr$+$ov$ и $ov$+$su$ соответственно, причем $|pr|>0$, $|su|>0$, $ov$ имеет максимальную возможную длину, а опетор (+) - это конкатенация строк.
Тогда определим $over(x, y) = ov$, $pref(x, y) = pr$ и $d(x, y) = |pr|$.
\end{definition}

\noindent Теперь запустим следующий алгоритм.
\begin{enumerate}
\item Если в множестве $S$ осталась ровно одна строка, то выведем её и прекратим работу алгоритма.
\item Иначе, переберём все упорядоченные пары различных строк $x$ и $y$ из $S$ и найдем среди них ту, у которой $|over(x, y)|$ максимален.
Если таких несколько можно выбрать любую. Например, лексикографически минимальную.
\item Найдя такую пару, выкинем из $S$ строки $x$ и $y$, а вместо них положим туда строку $pref(x, y)+y$. 
И перейдем к первому пункту алгоритма.
\end{enumerate}

\section{Доказательство}
Давайте посмотрим на то, что на самом деле происходит с исходными строками во время работы алгоритма.
Для начала, дадим несколько определений:

\begin{definition}
Пусть дана непустая строка $s$. 
Тогда $s_{i,j}$, где $1 \leq i \leq j \leq |s|$ - это подстрока $s$ начинающаяся с $i$-ого символа и заканчивающаяся на $j$-ом символе строки $s$ включительно.
\end{definition}

\begin{definition}
Пусть даны нупустые строки $s$, $t$ и число $pos$, тогда:
\[
	contains(s, t, pos) = 
	\left\{ 
		\begin{array}{lcl}
			1, & \mbox{если } pos \geq 1, (pos + |t| - 1) \leq |s| \mbox{ и строка t равна } s_{pos, pos + |t| - 1}\\
			0, & \mbox{иначе}\\ 
		\end{array} 
	\right.
\]
\end{definition}

\begin{definition}
Пусть даны непустые строки $s$, $t$, тогда:
\[
	index(s, t) = 
	\left\{ 
		\begin{array}{lcl}
			\mbox{минимальное число pos}, & \mbox{такое, что contains(s, t, pos) = 1}\\
			0, & \mbox{если такого числа не существует}\\ 
		\end{array} 
	\right.
\]
\end{definition}

\begin{definition}
Пусть $T = \{t_1,\dots,t_k\}, k \geq 1$ - упорядоченное по индексам множество непустых различных строк.
Будем считать, что $T$ свободно от подстрок. 
То есть, для любых различных строк $t_i,t_j \in T$ верно, что $index(t_i, t_j) = index(t_j, t_i) = 0$.
Тогда, $orderedSuperstrings(T)$ - это множество таких общих надстрок $T$, 
что $\forall i,j$ т.ч. $1 \leq i,j \leq k$ верно: $i \leq j \iff index(t, t_i) \leq index(t, t_j)$.
И $superstring(T)$ - это строка из $orderedSuperstrings(T)$ наименьшей длины.
\end{definition}

Теперь заметим, что $superstring(T)$ можно построить жадно:

\begin{theorem}
Пусть $T = \{t_1,\dots,t_k\}, k \geq 1$ - упорядоченное по индексам множество непустых строк, свободное от подстрок.
Тогда, $superstring(T) = \{ pref(t_1, t_2)+pref(t_2, t_3)+\dots+pref(t_{k-1}, t_k)+t_k\}$. 
\end{theorem}

\begin{proof}
Докажем индукцией по $k$.
Для $k = 1$ очевидно(сама строка должна лежать в надстроке и она же является своей надстрокой).
Пусть теперь для любого $k \leq K$ лемма верна. Тогда покажем, что она верна и для $k = K + 1$.

Докажем от противного. Пусть $g$ строка построенная жадно, а $b$ - кратчайшая, и $b \ne g$.
Пусть $begin(s, t) = index(s, t)$ и $end(s, t) = index(s, t) + |t| - 1$.
Заметим, что так как $T$ свободно от подстрок, то:
\begin{equation} \label{eq:begin_end}
	 \forall i,j \in \{ 1, \dots, k \} \mbox{ верно, что } begin(i) \leq begin(j) \iff end(i) \leq end(j).
\end{equation}
Заметим также, что $g$ и $b$ заканчиваются на строку $t_k$. Для $g$ это верно по построению, а для $b$ из оптимальности. 
Действительно, если $b = pr + t_k + su$, то суффикс $su$ можно спокойно отбросить, так как он ни на что не влияет($t_k$ - это последняя строчка из $T$).
Теперь рассмотрим начала этих строк:

\begin{lemma}
Строки $g$ и $b$ должны начинаться с $superstring(\{ t_1, \dots, t_{k-1} \})$.
\end{lemma}

\begin{proof}
Для строки $g$ - очевидно по построению.
Пусть $b$ начинается со строки $x$ из множества $orderedSuperstrings(\{ t_1, \dots, t_{k-1} \})$.
Очевидно, что $x$ заканчивается на $t_{k-1}$.
А значит, из утверждения (~\ref{eq:begin_end}) следует, что $|over(x, t_k)| \leq |t_{k-1}|$, так как в противном случае $t_{k-1}$ есть подстрока $t_k$.
Проще говоря, наложение $x$ на $t_k$ зависит только от $t_{k-1}$.
Из чего следует, что в качестве $x$ можно брать любую строку из $orderedSuperstrings(\{ t_1, \dots, t_{k-1} \})$, поскольку все они заканчиваются на $t_{k-1}$.
А значит, наиболее оптимально брать именно $superstring(\{ t_1, \dots, t_{k-1} \})$.
\end{proof}

Если для строки $z$ известны её начало $x$ и конец $y$, то кратчайшая строка такого вида очевидно строится жадно как $z = pref(x, y) + y$.
Из этого утверждения и предыдущего замечания следует, что $b = g$. Но они предполагались различными. Противоречие.
\end{proof}

Итак, для доказательства нам потребуется построить граф $G(S)$, где $S$ - исходное множество строк. 

\begin{definition}
$G(S)$ - полный ориентированный взвешенный граф = $(V, E)$, где $V = \{ 1, \dots, n \}$ при $n = |S|$, а вес ребра $(i, j) = d(s_i, s_j), \forall i,j \in \{ 1, \dots, n \}$.
\end{definition}

\begin{definition}
Пусть дан граф $G(S)$, тогда циклом в этом графе называется последовательность его вершин $c_1, \dots, c_p$, где $c_i \ne c_j$ $\forall i \ne j$.
При этом, длина цикла $|c| = p$, а вес $w(c) = d(s_{c_1}, s_{c_2}) + d(s_{c_2}, s_{c_3}) + \dots + d(s_{c_{p-1}}, s_{c_p}) + d(s_{c_p}, s_{c_1})$.
\end{definition}

\begin{definition}
Разбиением графа $G(S)$ на циклы называется такое множество циклов $C = \{ c_1, \dots, c_m \}$, 
что $c_i \cap c_j = \emptyset$ $\forall i \ne j$ и $\bigcup\limits_{i=1}^m c_i = \{ 1, \dots, n \}$ при $n = |S|$.
При этом вес разбиения $w(C) = \sum\limits_{i=1}^m w(c_i)$.
\end{definition}

\begin{definition}
OPT($S$) - это длина кратчайшей общей надстроки множества $S$.
\end{definition}

\begin{lemma}
Пусть $C$ - разбиение графа $G(S)$ на циклы минимального веса(т.ч. $w(C)$ минимально).
Тогда $w(C) \leq$ OPT($S$).
\end{lemma}

\begin{proof}
Для начала покажем, что длина кратчайшего гамильтонового цикла в этом графе $\leq$ OPT($S$).
Пусть $s$ - кратчайшая надстрока. Найдем порядок первых вхождений $s_i$ в $s$. Пусть это $s_{k_1}, \dots, s_{k_n}$.
Тогда, $w(k_1, \dots, k_n) \leq |s| =$ OPT($S$). Очевидно, что гамильтонов цикл - это частный случай разбиения графа на циклы.
Значит $w(C) \leq w(k_1, \dots, k_n) \leq$ OPT($S$).
\end{proof}

\begin{definition}
Пусть $c$ цикл в графе, тогда $strings(c)$ - это множество всех различных циклических сдвигов строки 
$pref(c_1, c_2)+pref(c_2, c_3)+\dots+pref(c_{p-1}, c_p)+pref(c_p, c_1)$, где $p = |c|$.
\end{definition}

\begin{definition}
Пусть $c$ цикл в графе, тогда $shifts(c) = |strings(c)|$.
\end{definition}

\begin{lemma}
Пусть $C$ разбиение графа на циклы минимального веса, $c$ - некоторый цикл из этого разбиения.
Тогда $w(c) \leq shifts(c)$.
\end{lemma}

\begin{proof}
Пусть $s \in strings(c)$ и $s = t^k$(строка $t$ повторённая $k$ раз), $t = s_{1, shifts(c)}, k = |s| / |t|$.
И пусть $w(c) > shifts(c)$.
Определим $t^\infty$ как бесконечную строку являющуюся последовательной конкатенацией бесконечного числа строк $t$.
Заметим, что $s_i$ подстрока $t^\infty$ $\forall i \in c$. Причем, $\forall ind \geq 0$ $\exists pos$, т.ч. $ind * |t| + 1 \leq pos \leq (ind + 1) * |t|$
и $contains(t^\infty, s_i, pos) = 1$. 
Вследсвие чего $index(t, s_i) \ne 0, \forall i \in c$. Значит существует цикл $c'$ веса $|t| = shifts(c) < w(c)$, содержащий все вершины из $c$.
Значит, $C$ не является разбиением графа на циклы минимального веса. Противоречие.
\end{proof}

\begin{theorem}
Пусть $C$ разбиение графа на циклы минимального веса, $c_1$, $c_2$ - два различных цикла из этого разбиения.
$s_1$ строка из цикла $c_1$, $s_2$ строка из цикла $c_2$. Тогда, $|over(s_1, s_2)| < w(c_1) + w(c_2)$.
\end{theorem}

\begin{proof}
Если $|s_1| < w(c_1)$ [$|s_2| < w(c_2)$], то $|over(s_1, s_2)| < |s_1|$[$|s_2|$] $< w(c_1)$[$w(c_2)$] $< w(c_1) + w(c_2)$.
Иначе, $|s_1| >= w(c_1)$ и $|s_2| >= w(c_2)$. 
Заметим, что $strings(c_1) \ne strings(c_2)$ так как в противном случае существует циклы $c_1$ и $c_2$ неотличимы 
и следовательно, выбранное разбиение неоптимально.

Рассмотрим строку $u = over(s_1, s_2)$ и пусть $|u| >= w(c_1) + w(c_2)$.
Из цикличности $s_1$ и $s_2$ следует цикличность $u$ с периодами $shifts(c_1)$ и $shifts(c_2)$.
Если $w(c_1) = w(c_2)$, то и $strings(c_1) = strings(c_2)$ так как $u$ общая подстрока $s_1$ и $s_2$, но $strings(c_1) \ne strings(c_2)$.
Значит $w(c_1) \ne w(c_2)$. Без ограничения общности будем полагать, что $w(c_1) > w(c_2)$.
Тогда заметим следующее:
\[
	u_{1, w(c_1)} = 
	u_{1 + w(c_2), w(c_1) + w(c_2)} = 
	u_{1 + w(c_2), w(c_1)} + u_{w(c_1) + 1, w(c_1) + w(c_2)} = 
	u_{1 + w(c_2), w(c_1)} + u_{1, w(c_2)}.
\]
Значит циклический сдвиг строки $u_{1, w(c_1)}$ на $w(c_2)$ символов вправо переводит её в саму себя.
По предыдущей лемме мы знаем, что $w(c_1) \leq shifts(c_1)$.
Следовательно, $shifts(c_1) \leq w(c_2) < w(c_1) \leq shifts(c_1)$. 
Противоречие.
\end{proof}

\noindent Наконец, построим по нашему оптимальному разбиению ответ на задачу.

\begin{definition}
Пусть $C$ разбиение графа $G(S)$ на циклы и $c \in C$.
Определим $superstring(c) = pref( c_1, c_2 ) + pref( c_2, c_3 ) + \dots + pref( c_{p-1}, c_p ) + c_p$.
\end{definition}

\begin{definition}
Пусть $C = \{c_1, \dots, c_m\}$ разбиение графа $G(S)$ на циклы.
Определим $superstring(C)$ = $pref( superstring(c_1), superstring(c_2) )$ + $\dots$ + $pref( superstring(c_{m-1}), superstring(c_m) ) + superstring(c_m)$.
\end{definition}

\begin{theorem}
Пусть $C = \{c_1, \dots, c_m\}$ разбиение графа $G(S)$ на циклы минимального веса. Тогда $|superstring(C)|$ $\leq$ $4*OPT(s)$
\end{theorem}

\begin{proof}
Пусть $maxword(c)$ - слово из цикла $c$ наибольшей длины.
Рассмотрим мноджество слов $S_c = \{ maxword(c_1), \dots, maxword(c_m) \}$.
И пусть $C' = \{c'_1, \dots, c'_k\}$ разбиение графа $G(S_c)$ на циклы минимального веса.
Тогда, в следствие предыдущей теоремы, $w(C') \leq \sum\limits_{i=1}^m ( |maxword(c_i)| - 2 * w(c_i) )$.
Причем очевидно, что $w(C') \leq OPT(S_c) \leq OPT(S)$. Значит $OPT(S) \geq \sum\limits_{i=1}^m ( |maxword(c_i)| - 2 * w(c_i) )$.
Также, ранее мы уже заметили, что $OPT(S) \geq w(C)$.

Итак, рассмотрим полученныю строку $superstring(C)$. Очевидно, что $superstring(C) \leq \sum\limits_{i=1}^m ( |maxword(c_i)| + w(c_i) )$, 
что равно $\sum\limits_{i=1}^m ( |maxword(c_i)| - 2 * w(c_i) ) + \sum\limits_{i=1}^m 3 * w(c_i)$ $\leq$ $OPT(S) + 3 * OPT(S) = 4 * OPT(S)$.
\end{proof}

Мы доказали, что задачу поиска 4-приближения можно свести к поиску разбиения графа $G(S)$ на циклы минимального веса.
Осталось только показать, что Предложенный ранее алгоритм дает приближение не хуже.

Пусть $T = \{t_1,\dots,t_k\}, k \geq 1$, $P = \{p_1,\dots,p_m\}, m \geq 1$ - упорядоченные по индексам множества непустых строк, свободные от подстрок.
Тогда, $over( superstring(T), superstring(P) )$ зависит только от $t_k$ и $p_m$.
Это следует из утверждения (~\ref{eq:begin_end}).
Значит, во время работы жадного алгоритма каждая строчка из множества $S$ есть $superstring(T)$ для некоторого $T$.
Причем $T$ соответствует пути в графе $G(S)$.
В результате мы получим некоторую последовательную склейку строк. Каждая склейка соответствует некотору ребру в графе.
Итого, результат жадного алгоритма соответствует гамильтонову пути в графе.

По другому можно представить работу нашего алгоритма следующим образом.
Есть список всех ребер $(i, j)$ графа представленный в порядке уменьшения величины $|over(s_i, s_j)|$.
Изначально все ребра не вычеркнуты.
Алгоритм проходит по всем ребрам в данном порядке. Если ребро $(i, j)$ не вычеркнуто, 
то он добавляет его в ответ и вычеркивает все ребра вида $(i, x)$ и $(x, j)$ $\forall x \in \{ 1, \dots, n \}$, $n = |S|$.
Не трудно доказать, что результат будет один и тот же.

\begin{definition}
Пусть дан порядок ребер в жадном алгоритме, тогда будем говорить, что ребро $e_1$ лучше ребра $e_2$ если $e_1$ идет раньше $e_2$ в этом списке.
\end{definition}

\begin{lemma}
Пусть даны непустые строки $a,b,c,d$, такие что ни одна строка не является подстрокой любой другой строки.
Тогда $|over(a, b)| \geq max( |over(c, b)|, |over(a, d)| )$ $\Rightarrow$ $|over(a, b)| + |over(c, d)| \geq |over(c, b)| + |over(a, d)|$.
\end{lemma}

\begin{proof}
Возьмем строку $s = superstring(\{ c, a, b, d \})$.
$over(c, b)$ - это префикс $over(a, b)$. $over(a, d)$ - это суффикс $over(a, b)$.
Значит, если $|over(c, d)| = 0$, то $|over(c, b)| + |over(a, d)| \leq |over(a, b)|$.
А если $|over(c, d)| > 0$, то $|over(c, b)| + |over(a, d)| = |over(a, b)| + |over(c, d)|$.
\end{proof}

\begin{theorem}
Пусть $M$ граф, соответствующий результату жадного алгоритма, а $C$ разбиение графа $G(S)$ на циклы минимального веса, т.ч. оно имеет с $M$ набольшее число общих ребер.
Тогда, $M = C$.
\end{theorem}

\begin{proof}
Пусть $e = (u, v)$ такое ребро из $C \Delta M$, что оно лучше всех остальных ребер из этого множества.
\begin{enumerate}
\item Если $e \in C \setminus M $, тогда в $M$ должно существовать ребро $f = (i, j) \ne e$, т.ч. либо $i == u$, либо $j == v$.
Причем, вследствие жадности алгоритма $f$ будет лучше чем $s$. Что противоречит выбору $e$.
\item Если $e \in M \setminus C $, тогда в $C$ должны существовать ребра $a = (i, v)$ и $b = (u, j)$, т.ч. $e$ лучше чем $a$ и $b$.
Значит, по предыдущей лемме: $|over(s_u, s_v)| \geq max( |over(s_i, s_v)|, |over(s_u, s_j)| )$ $\Rightarrow$ 
$|over(s_u, s_v)| + |over(s_i, s_j)| \geq |over(s_i, s_v)| + |over(s_u, s_j)|$.
Следовательно, если заменить ребра $a$ и $b$ из $C$ на $e$ и $(i, j)$, то полученное покрытие $C'$ будет не хуже по длине и будет содержать на одно общее с $M$ больше.
Что противоречит выбору $C$.
\end{enumerate}
\end{proof}

Благодаря этой теореме мы выяснили, что жадный алгоритм, предоставляет нам ответ не хуже.
Зато, на практике он и работает быстрее и ответ дает лучше, за счет того, что разворачивает циклы наиболее выгодным образом.

\section{NP-полнота}

WIP

\end{document}
