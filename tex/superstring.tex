\documentclass[a4paper,10pt]{article}

\usepackage{cmap}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}

\usepackage[russian, english]{babel}
\usepackage{titlesec}
\usepackage{amsthm}
\usepackage{lipsum}

\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm,bindingoffset=0cm]{geometry}

\newcommand{\B}{\textbf}
\newcommand{\var}[1]{$\B{#1}$}

\title{\B{Общая надстрока наименьшей длины}}
\author{Андрей Осипов}

\newtheorem{theorem}{Теорема}
\newtheorem{lemma}{Лемма}
\newtheorem{definition}{Определение}
\newtheorem{note}{Замечание}

%%%%%%%%%% Document %%%%%%%%%%
\begin{document}
\Russian
\maketitle

\section{Постановка задачи}
Дан набор строк $S = \{s_1,\dots,s_n\}$ над конечным алфавитом. 
Требуется найти, строку $s$ минимальной длины, содержащую как подстроку каждую строку из данного набора.

Пусть язык $L$ это множество пар вида $(S, k)$ для которых верно, что такая строка $s$ существует, и имеет длину не больше $k$.
Тогда задача разрешения языка $L$ является NP-полной.
Доказательство этого факта будет приведено позже.
А пока, мы ослабим условие следующим образом: пускай теперь требуется найти такую строку $t$, 
что она так же как и $s$ содержит всякую строку из $S$ как подстроку, и при этом $|t| \leq 4*|s|$

\section{Алгоритм}
Алгоритм для решения этой задачи на первый взгляд может показаться крайне наивным.
Но в дальнейшем выяснится, что этого вполне достаточно для достижения даже такой близкой границы.
Более того, на практике полученный ответ разрастается не более чем вдвое.

Итак, без ограничения общности будем считать, что среди строк из $S$ нет таких двух $x$ и $y$, что $x$ подстрока $y$.
В противном случае от $x$ можно спокойно избавиться.

\begin{definition}
Пусть даны строки $x$ и $y$.
Представим их как $pr$+$ov$ и $ov$+$su$ соответственно, причем $|pr|>0$, $|su|>0$, $ov$ имеет максимальную возможную длину, а опетор (+) - это конкатенация строк.
Тогда определим $over(x, y) = ov$, $pref(x, y) = pr$ и $d(x, y) = |pr|$.
\end{definition}

\noindent Теперь запустим следующий алгоритм.
\begin{enumerate}
\item Если в множестве $S$ осталась ровно одна строка, то выведем её и прекратим работу алгоритма.
\item Иначе, переберём все упорядоченные пары различных строк $x$ и $y$ из $S$ и найдем среди них ту, у которой $|over(x, y)|$ максимален.
Если таких несколько можно выбрать любую. Например, лексикографически минимальную.
\item Найдя такую пару, выкинем из $S$ строки $x$ и $y$, а вместо них положим туда строку $pref(x, y)+y$. 
И перейдем к первому пункту алгоритма.
\end{enumerate}

\section{Доказательство}
Давайте посмотрим на то, что на самом деле происходит с исходными строками во время работы алгоритма.
Для начала, дадим несколько определений:

\begin{definition}
Пусть дана непустая строка $s$. 
Тогда $s_{i,j}$, где $1 \leq i \leq j \leq |s|$ - это подстрока $s$ начинающаяся с $i$-ого символа и заканчивающаяся на $j$-ом символе строки $s$ включительно.
\end{definition}

\begin{definition}
Пусть даны нупустые строки $s$, $t$ и число $pos$, тогда:
\[
	contains(s, t, pos) = 
	\left\{ 
		\begin{array}{lcl}
			1, & \mbox{если } pos \geq 1, (pos + |t| - 1) \leq |s| \mbox{ и строка t равна } s_{pos, pos + |t| - 1}\\
			0, & \mbox{иначе}\\ 
		\end{array} 
	\right.
\]
\end{definition}

\begin{definition}
Пусть даны непустые строки $s$, $t$, тогда:
\[
	index(s, t) = 
	\left\{ 
		\begin{array}{lcl}
			\mbox{минимальное число pos}, & \mbox{такое, что contains(s, t, pos) = 1}\\
			0, & \mbox{если такого числа не существует}\\ 
		\end{array} 
	\right.
\]
\end{definition}

\begin{definition}
Пусть $T = \{t_1,\dots,t_k\}, k \geq 1$ - упорядоченное по индексам множество непустых различных строк.
Будем считать, что $T$ свободно от подстрок. 
То есть, для любых различных строк $t_i,t_j \in T$ верно, что $index(t_i, t_j) = index(t_j, t_i) = 0$.
Тогда, $orderedSuperstrings(T)$ - это множество таких общих надстрок $T$, 
что $\forall i,j$ т.ч. $1 \leq i,j \leq k$ верно: $i \leq j \iff index(t, t_i) \leq index(t, t_j)$.
И $superstring(T)$ - это строка из $orderedSuperstrings(T)$ наименьшей длины.
\end{definition}

Теперь заметим, что $superstring(T)$ можно построить жадно:

\begin{lemma}
Пусть $T = \{t_1,\dots,t_k\}, k \geq 1$ - упорядоченное по индексам множество непустых строк, свободное от подстрок.
Тогда, $superstring(T) = \{ pref(t_1, t_2)+pref(t_2, t_3)+\dots+pref(t_{k-1}, t_k)+t_k\}$. 
\end{lemma}

\begin{proof}
Докажем индукцией по $k$.
Для $k = 1$ очевидно(сама строка должна лежать в надстроке и она же является своей надстрокой).
Пусть теперь для любого $k \leq K$ лемма верна. Тогда покажем, что она верна и для $k = K + 1$.

Докажем от противного. Пусть $g$ строка построенная жадно, а $b$ - кратчайшая, и $b \ne g$.
Пусть $begin(s, t) = index(s, t)$ и $end(s, t) = index(s, t) + |t| - 1$.
Заметим, что так как $T$ свободно от подстрок, то:
\begin{equation} \label{eq:begin_end}
	 \forall i,j \in \{ 1, \dots, k \} \mbox{ верно, что } begin(i) \leq begin(j) \iff end(i) \leq end(j).
\end{equation}
Заметим также, что $g$ и $b$ заканчиваются на строку $t_k$. Для $g$ это верно по построению, а для $b$ из оптимальности. 
Действительно, если $b = pr + t_k + su$, то суффикс $su$ можно спокойно отбросить, так как он ни на что не влияет($t_k$ - это последняя строчка из $T$).
Теперь рассмотрим начала этих строк:

\begin{note}
Строки $g$ и $b$ должны начинаться с $superstring(\{ t_1, \dots, t_{k-1} \})$.
\end{note}

\begin{proof}
Для строки $g$ - очевидно по построению.
Пусть $b$ начинается со строки $x$ из множества $orderedSuperstrings(\{ t_1, \dots, t_{k-1} \})$.
Очевидно, что $x$ заканчивается на $t_{k-1}$.
А значит, из утверждения (~\ref{eq:begin_end}) следует, что $|over(x, t_k)| \leq |t_{k-1}|$, так как в противном случае $t_{k-1}$ есть подстрока $t_k$.
Проще говоря, наложение $x$ на $t_k$ зависит только от $t_{k-1}$.
Из чего следует, что в качестве $x$ можно брать любую строку из $orderedSuperstrings(\{ t_1, \dots, t_{k-1} \})$, поскольку все они заканчиваются на $t_{k-1}$.
А значит, наиболее оптимально брать именно $superstring(\{ t_1, \dots, t_{k-1} \})$.
\end{proof}

Если для строки $z$ известны её начало $x$ и конец $y$, то кратчайшая строка такого вида очевидно строится жадно как $z = pref(x, y) + y$.
Из этого утверждения и предыдущего замечания следует, что $b = g$. Но они предполагались различными. Противоречие.
\end{proof}

Итак, для доказательства нам потребуется построить граф $G(S)$, где $S$ - исходное множество строк. 

\begin{definition}
$G(S)$ - полный ориентированный взвешенный граф = $(V, E)$, где $V = \{ 1, \dots, n \}$ при $n = |S|$, а вес ребра $(i, j) = d(s_i, s_j), \forall i,j \in \{ 1, \dots, n \}$.
\end{definition}

\begin{definition}
Пусть дан граф $G(S)$, тогда циклом в этом графе называется последовательность его вершин $c_1, \dots, c_p$, где $c_i \ne c_j$ $\forall i \ne j$.
При этом, длина цикла $|c| = p$, а вес $w(c) = d(s_{c_1}, s_{c_2}) + d(s_{c_2}, s_{c_3}) + \dots + d(s_{c_{p-1}}, s_{c_p}) + d(s_{c_p}, s_{c_1})$.
\end{definition}

\begin{definition}
Разбиением графа $G(S)$ на циклы называется такое множество циклов $C = \{ c_1, \dots, c_m \}$, 
что $c_i \cap c_j = \emptyset$ $\forall i \ne j$ и $\bigcup\limits_{i=1}^m c_i = \{ 1, \dots, n \}$ при $n = |S|$.
При этом вес разбиения $w(C) = \sum\limits_{i=1}^m w(c_i)$.
\end{definition}

\begin{definition}
OPT($S$) - это длина кратчайшей общей надстроки множества $S$.
\end{definition}

\begin{lemma}
Пусть $C$ - разбиение графа $G(S)$ на циклы, т.ч. $w(C)$ минимально.
Тогда $w(C) \leq$ OPT($S$).
\end{lemma}

\begin{proof}
Для начала покажем, что длина кратчайшего гамильтонового цикла в этом графе $\leq$ OPT($S$).
Пусть $s$ - кратчайшая надстрока. Найдем порядок первых вхождений $s_i$ в $s$. Пусть это $s_{k_1}, \dots, s_{k_n}$.
Тогда, $w(k_1, \dots, k_n) \leq |s| =$ OPT($S$). Очевидно, что гамильтонов цикл - это частный случай разбиения графа на циклы.
Значит $w(C) \leq w(k_1, \dots, k_n) \leq$ OPT($S$).
\end{proof}

\begin{definition}
OPT($S$) - это длина кратчайшей общей надстроки множества $S$.
\end{definition}

\section{NP-полнота}

\begin{theorem}
the1
\end{theorem}

\end{document}
