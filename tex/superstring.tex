\documentclass[a4paper,12pt]{article}

\usepackage{cmap}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}

\usepackage[russian, english]{babel}
\usepackage{titlesec}
\usepackage{amsthm}
\usepackage{lipsum}

\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm,bindingoffset=0cm]{geometry}

\title{Общая надстрока наименьшей длины}
\author{Андрей Осипов}

\newtheorem{theorem}{Теорема}
\newtheorem{lemma}{Лемма}
\newtheorem{definition}{Определение}

\newcommand{\B}{\textbf}
\newcommand{\var}[1]{$\B{#1}$}

%%%%%%%%%% Document %%%%%%%%%%
\begin{document}
\Russian
\maketitle

\section{Постановка задачи}
Дан набор строк $S = \{s_1,\dots,s_n\}$ над конечным алфавитом. 
Требуется найти, строку $s$ минимальной длины, содержащую как подстроку каждую строку из данного набора.

Пусть язык $L$ это множество пар вида $(S, k)$ для которых верно, что такая строка $s$ существует, и имеет длину не больше $k$.
Тогда задача разрешения языка $L$ является NP-полной.
Доказательство этого факта будет приведено позже.
А пока, мы ослабим условие следующим образом: пускай теперь требуется найти такую строку $t$, 
что она так же как и $s$ содержит всякую строку из $S$ как подстроку, и при этом $|t| \leq 4*|s|$

\section{Алгоритм}
Алгоритм для решения этой задачи на первый взгляд может показаться крайне наивным.
Но в дальнейшем выяснится, что этого вполне достаточно для достижения даже такой близкой границы.
Более того, на практике полученный ответ разрастается не более чем вдвое.

Итак, без ограничения общности будем считать, что среди строк из $S$ нет таких двух $x$ и $y$, что $x$ подстрока $y$.
В противном случае от $x$ можно спокойно избавиться.

\begin{definition}
Пусть даны строки $x$ и $y$.
Представим их как $pr$+$ov$ и $ov$+$su$ соответственно, причем $|pr|>0$, $|su|>0$, $ov$ имеет максимальную возможную длину, а опетор (+) - это конкатенация строк.
Тогда определим $over(x, y) = ov$, $pref(x, y) = pr$ и $d(x, y) = |pr|$.
\end{definition}

\noindent Теперь запустим следующий алгоритм.
\begin{enumerate}
\item Если в множестве $S$ осталась ровно одна строка, то выведем её и прекратим работу алгоритма.
\item Иначе, переберём все упорядоченные пары различных строк $x$ и $y$ из $S$ и найдем среди них ту, у которой $|over(x, y)|$ максимален.
Если таких несколько можно выбрать любую. Например, лексикографически минимальную.
\item Найдя такую пару, выкинем из $S$ строки $x$ и $y$, а вместо них положим туда строку $pref(x, y)+y$. 
И перейдем к первому пункту алгоритма.
\end{enumerate}

\section{Доказательство}
Давайте посмотрим на то, что на самом деле происходит с исходными строками во время работы алгоритма.
Для начала, дадим несколько определений:

\begin{definition}
Пусть дана непустая строка $s$. 
Тогда $s_{i,j}$, где $1 \leq i \leq j \leq |s|$ - это подстрока $s$ начинающаяся с $i$-ого символа и заканчивающаяся на $j$-ом символе строки $s$ включительно.
\end{definition}

\begin{definition}
Пусть даны нупустые строки $s$, $t$ и число $pos$, тогда:
\[
	contains(s, t, pos) = 
	\left\{ 
		\begin{array}{lcl}
			1, & \mbox{если } pos \geq 1, (pos + |t| - 1) \leq |s| \mbox{ и строка t равна } s_{pos, pos + |t| - 1}\\
			0, & \mbox{иначе}\\ 
		\end{array} 
	\right.
\]
\end{definition}

\begin{definition}
Пусть даны непустые строки $s$, $t$, тогда:
\[
	index(s, t) = 
	\left\{ 
		\begin{array}{lcl}
			\mbox{минимальное число pos}, & \mbox{такое, что contains(s, t, pos) = 1}\\
			0, & \mbox{если такого числа не существует}\\ 
		\end{array} 
	\right.
\]
\end{definition}

\begin{definition}
Пусть $T = \{t_1,\dots,t_k\}, k \geq 1$ - упорядоченное множество непустых строк.
Тогда, $orderedSuperstrings(T)$ - это множество таких общих надстрок $T$, 
что $\forall i,j$ т.ч. $1 \leq i,j \leq k$ верно: $i \leq j \iff index(t, t_i) \leq index(t, t_j)$.
И $superstring(T)$ - это строка из $orderedSuperstrings(T)$ наименьшей длины.
\end{definition}

Теперь заметим, что $superstring(T)$ можно построить жадно:

\begin{lemma}
Пусть $T = \{t_1,\dots,t_k\}, k \geq 1$ - упорядоченное множество непустых строк.
Тогда, $superstring(T) = \{ pref(t_1, t_2)+pref(t_2, t_3)+\dots+pref(t_{k-1}, t_k)+t_k\}$. 
\end{lemma}

\proof
Докажем индукцией по $k$.
Для $k = 1$ очевидно(сама строка должна лежать в надстроке и она же является своей надстрокой).
Пусть теперь для любого $k \leq K$ лемма верна. Тогда докажем, что она верна и для $k = K + 1$.

Рассмотрим 

\section{NP-полнота}

\begin{theorem}
the1
\end{theorem}

\end{document}
